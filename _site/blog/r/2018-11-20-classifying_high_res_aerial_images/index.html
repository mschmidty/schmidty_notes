<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classifying High Resolution Aerial Imagery - Part 1</title>
    <meta name="description" content="">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body>
    <header>
      
    </header>

    <main>
      <article class="post-content">
  <header class="post-header">
    <h1 class="post-title">Classifying High Resolution Aerial Imagery - Part 1</h1>
    <div class="post-meta">
      <time datetime="Invalid DateTime" class="post-time">November 20, 2018</time>
      <span>| tags:</span>
      <ul class="tags-list post-tag-list">
      
        
        <li><a href="/tags/r/" class="tag-list-tag">R</a></li>
      
        
        <li><a href="/tags/gis/" class="tag-list-tag">GIS</a></li>
      
        
        <li><a href="/tags/r/" class="tag-list-tag">R</a></li>
      
        
        <li><a href="/tags/remote-sensing/" class="tag-list-tag">Remote Sensing</a></li>
      
      </ul>
    </div>
  </header>
  <p>The following note documents a proof of concept for classifying vegetation with 4 band 0.1m aerial imagery. We used sagebrush, bare ground, grass, and PJ for classes.  approximately 300 training polygons were used as a training data.</p>
<h2>What I Learned</h2>
<h3>Success</h3>
<p>Random forests was quite successful in classification. The largest error occurred in sagebrush, with an out of bag error of about 3%.  However, because this was a first attempt, I did not use a train and validation set.  Future iterations of this process should definitely use a more rigorous validation methodology to inform model decisions.</p>
<h3>Failures</h3>
<p>Shadows presented the biggest challenge to classification.  There  are two ways to handle this:</p>
<ul>
<li><strong>Segmentation</strong> - We could try to segment out the shadows prior to classification, and use the shadows as a separate class.  We would need to thing about if this would through off any cover estimates.  At first thought I would say no, because it would be standardized across a tile.</li>
<li><strong>Adding in predictors</strong> - I think if we used our vegetation polygons as a predictive layer random forests may be able to split the shadows.  This would also require us however to draw the shadows as part of a plant so that random forests associates the shadow with the plant/tree.<a href="https://fickse.wordpress.com/2015/06/18/quick-and-dirty-object-based-segmentation-in-r/">Segementation Resource</a></li>
</ul>
<h2>Compute power</h2>
<p>Compute power was a huge limitation.  One tile of imagery is about 12 GB in memory. That's about 1/3 of my 32 GB of memory.  I've heard that tensorflow, which uses the GPU, can perform random forests, but I haven't figured out a way to do that in r.</p>
<h3>Future Loops</h3>
<p>I do not think we have the compute power to perform this process across the entire basin. However, I do think that we could loop through each tile with something like <code>lapply</code>.  The next step would be to clean everything up and put the process into a function that you could then predict each tile individually.  I think we may need to normalize the statistics on the rasters first however.</p>
<h2>Some Results</h2>
<h3>The Final prediction</h3>
<figure><a href="/img/r/assets/veg_class/subset_classification_example.jpg"><img src="/img/r/assets/veg_class/subset_classification_example.jpg" alt="Raster Image of vegetation classified into sagebrush, pinyon/juniper, bare ground and grass."></a></figure>
<p>You can see the model did pretty well in classifying the image.  However, the failure to classify the PJ shadows correctly is very evident.
{: .caption}</p>
<h3>The Original Four Band Image</h3>
<figure><a href="/img/r/assets/veg_class/ortho.jpg"><img src="/img/r/assets/veg_class/ortho.jpg" alt="Ortho Imagery of the area classified above"></a></figure>
<p>The same extent as the classification raster above.
{: .caption}</p>
<h3>An example of the training polygons</h3>
<figure><a href="/img/r/assets/veg_class/training_classes_example.jpg"><img src="/img/r/assets/veg_class/training_classes_example.jpg" alt="Some examples of the training polygons used to train the model. "></a></figure>
<p>An example of my training polygons.
{: .caption}</p>
<h2>Notes</h2>
<p>If we wanted to publish we would need to validate 50 points per predicted class to statistically validate the process.</p>
<h2>R Scripts</h2>
<h3>Load Libraries</h3>
<pre><code class="language-r">library(raster)
library(tidyverse)
library(randomForest)
library(rgdal)
</code></pre>
<h3>Load the needed datasets</h3>
<pre><code class="language-r">raster&lt;-brick(&quot;data/raster/Basin0301.tif&quot;) ## Tile to be classified.
## supervisor&lt;-raster(&quot;data/raster/supervisor12N&quot;) ## didn't end up using this layer because rasters on a 0.1m scale in ArcMap can't be merged in r because of the decimal error. This applies to test raster as well.
testshape&lt;-readOGR(&quot;data/shape&quot;, layer=&quot;test&quot;) ## A subset of Basin0301.tif so that we didn't have to run the prediction on the whole raster.
shape&lt;-readOGR(dsn=&quot;data/shape&quot;, layer=&quot;supervised12N&quot;) ## Read in the classification polygons
##test_raster&lt;-raster(&quot;data/raster/test_fit&quot;) ## I don't remember why I loaded this????
</code></pre>
<h3>Set up raster and add NDVI layer</h3>
<pre><code class="language-r">names(raster)&lt;-c(&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;) ## Rename Bands for ease of use
ndvi&lt;-overlay(raster$b4, raster$b3, fun=function(x,y){(x-y)/(x+y)}) ## Create a NDVI layer
cov&lt;-addLayer(raster,ndvi) ## Merge NDVI and the tiel imagery
names(cov)&lt;-c(&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;ndvi&quot;) ## Rename NDVI to &quot;ndvi&quot;, all other layers stay the samel.

</code></pre>
<h3>Check Alignment</h3>
<p>Make sure that the aerial tile  has the same extent as the training shapefile using <code>ndvi</code> layer.</p>
<pre><code class="language-r">plot(ndvi)
plot(shape, add=T)
</code></pre>
<h3>Convert the Class field to number</h3>
<pre><code class="language-r">shape@data$code&lt;-as.numeric(shape@data$Class)
shape@data
</code></pre>
<h3>Rasterize the training shapefile</h3>
<pre><code class="language-r">classes&lt;-rasterize(shape, ndvi, field=&quot;code&quot;)
plot(classes)
</code></pre>
<h3>Clip and mask</h3>
<p>First clip that aerial image to the extent of the classes layer (not the same as ArcMap Clip). Then mask (use classes geometry).</p>
<pre><code class="language-r">covmask&lt;-crop(cov, extent(classes))
covmask2&lt;-mask(covmask, classes)
plot(covmask2)
</code></pre>
<h3>Merge Training Dataset to Clipped Dataset.</h3>
<pre><code class="language-r">names(classes)&lt;-&quot;class&quot;
train_brick&lt;-addLayer(covmask2, classes)
</code></pre>
<h3>Get Values From Raster</h3>
<p>I will need to run this step through again to make sure it is correct.  For some reason when the aerial raster is clipped to the geometry of the training polygons, all of the clipped out cells remain as NAs (as far as I konw there is no way around this). To run random forests you need to remove the NAs. Removing the NAs took up almost all of my computers memory. I eventually got it to work, by removing everything in memory and then running the <code>filter(train_table2, !is.na(class))</code> I believe, but I can't quite remember.  To do this, I may have needed to save the <code>train_table</code> as a RDS and then re-load it after restarting R so that the machines memory was clean. I'll update once I run this part again, it just takes so long (45min to an hour) I didn't have time to run it twice.</p>
<pre><code class="language-r">train_table&lt;-getValues(train_brick) ## Takes a lot of time
saveRDS(train_table, &quot;data/train_table2.rds&quot;)
train_table&lt;-readRDS(&quot;data/train_table2.rds&quot;)
library(rgr)
train_table2&lt;-remove.na(train_table)
train_table2&lt;-as.tibble(train_table)
train_table3&lt;-filter(train_table2, !is.na(class))
train_table3

</code></pre>
<h2>Run Random Forests</h2>
<p>Build the model.</p>
<pre><code class="language-r">set.seed(415)
fit&lt;-randomForest(as.factor(class)~.,
                  data=train_table3,
                  importance=TRUE,
                  ntree=200
                  )
fit ## See the results.
varImpPlot(fit) ## View the most important perdictors.
saveRDS(fit, &quot;data/forests/fit1.rds&quot;) ## Save the prediction
</code></pre>
<h3>Prepare raster datasets to Run the Prediction</h3>
<p>Format the datasets into so that the training dataset and the predicted dataset have the same layers (4 light bands and ndvi).</p>
<pre><code class="language-r">testshape_raster&lt;-rasterize(testshape, raster) ##convert testshape (subset of aerial imagery) to raster with same pixel size as raster.
test_fit&lt;-crop(raster, extent(testshape)) ##crop raster to testshape
plot(test_fit) ##Look at test fit
names(test_fit)&lt;-c(&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;) ## rename testfit names to match training set.
ndvi2&lt;-overlay(test_fit$b4, test_fit$b3, fun=function(x,y){(x-y)/(x+y)}) ## add ndvi
test_fit_comb&lt;-addLayer(test_fit, ndvi2) ## Merge the layers
names(test_fit_comb)&lt;-c(&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;ndvi&quot;) ##rename ndvi header to ndvi.

</code></pre>
<h3>Run the prediction on the data subest and the whole dataset.</h3>
<pre><code class="language-r">predicted_plot&lt;-raster::predict(test_fit_comb, fit, OOB=T) ## Predict subset
##predicted_whole&lt;-raster::predict(cov, fit, OOB=T) ## predict whole dataset - This takes over an hour with a 32GB machine.

</code></pre>
<h3>Save everything</h3>
<p>When you write the rasters with <code>writeRaster</code> the rasters still need to be projected once they are pulled into ArcMap.  I'm srue there is a way to save them with a projection, but I haven't figured it out yet.</p>
<pre><code class="language-r">saveRDS(predicted_plot, &quot;data/forests/predicted_raster.rds&quot;)
saveRDS(predicted_whole, &quot;data/forests/predicted_whole_raster.rds&quot;)
predicted_plot2&lt;-predicted_plot

writeRaster(predicted_plot2, &quot;data/raster/prediction.asc&quot;)
writeRaster(predicted_whole, &quot;data/raster/prediction_whole.asc&quot;)
</code></pre>

</article>

    </main>

    <footer></footer>

    <!-- Current page: /blog/r/2018-11-20-classifying_high_res_aerial_images/ -->
  </body>
</html>